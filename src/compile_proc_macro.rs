use ::std::{
    env,
    io::{self, Write},
    process::{Command, Stdio},
    ops::Not as _,
};

use ::proc_macro2::{
    Span,
    TokenStream as TokenStream2,
};
use ::quote::{
    quote,
    quote_spanned,
};
use ::syn::{*,
    spanned::Spanned,
};

/// Elided errors default to `::syn::Error`
type Result<Ok, Err = ::syn::Error> = ::core::result::Result<Ok, Err>;

/// Invoke rustc to compile the input `source` code as a
/// `wasm32-unknown-unknown` crate with dependencies on the bundled pre-compiled
/// `unicode_xid`, `proc_macro2`, `syn`, and `quote`, rlibs.
fn compile_to_wasm (
    mod_name: &'_ ::syn::Ident,
    source: &'_ str,
) -> Result<String, io::Error>
{
    define_strings! {
        const WASM_TARGET = "wasm32-unknown-unknown";
        const CRATE_NAME = "inline_proc_macros";
    }
    let ref out_dir = [renv!("OUT_DIR"), "inline_proc_macros"].join("/");
    let _ = ::std::fs::create_dir_all(out_dir);
    let wasm_path = format!("{}/{}.wasm", out_dir, mod_name);
    let mut rustc = Command::new(renv!("RUSTC"));
    // rustc.current_dir(tmp.path());
    rustc.args(&[
        "-v",
        "-", // input source code is piped
        "-o", &wasm_path,
        "--target", WASM_TARGET,
        "--edition", "2018",
        "--crate-type", "cdylib",
        "--crate-name", CRATE_NAME,
        "-L",
            &format!(
                "dependency={}/wasm32-unknown-unknown/release/",
                env!("OUT_DIR"),
            ),
        "--color=always",
    ]);
    [
        "proc_macro2", "quote", "syn", "unicode_xid",
    ]
    .iter().copied()
    .for_each(|rlib| {
        let ref lib_path = 
            // Note: this is using the compile-time environment of this very
            // crate, not the user crate: this is thus fetching
            // the `.rlib`s generated by the `../build.rs` script
            format!(
                "{OUT_DIR}/wasm32-unknown-unknown/release/lib{rlib}.rlib",
                OUT_DIR = env!("OUT_DIR"),
                rlib = rlib,
            )
        ;
        rustc.arg("--extern");
        rustc.arg([rlib, lib_path].join("="));
    });

    // Spawn the compiler
    let mut rustc_process = rustc.stdin(Stdio::piped()).spawn()?;
    // Pipe the source code in (scoped binding to ensure pipe is closed).
    match rustc_process.stdin.take().unwrap() { mut rustc_stdin => {
        rustc_stdin.write_all(source.as_bytes())?;
        rustc_stdin.write_all(include_bytes!("appended_epilogue.rs"))?;
    }}
    // Wait for the compiler to succeed.
    let status = rustc_process.wait()?;
    if status.success() {
        Ok(wasm_path)
    } else {
        Err(io::Error::new(
            io::ErrorKind::Other,
            format!("{:?} exited with status {}", rustc, status),
        ))
    }
}

/// Entry point of the compilation process.
/// 
/// Input: module name and proc_macro source code present in `src/mod_name.rs`
/// 
/// Output (on success):
/// 
///   - It generates a `some/path/to/generated/mod_name.wasm` file containing
///     the compiled WASM bytecode;
/// 
///   - It returns a bunch of `macro_rules!` macro definitions that refer to it,
///     based on each identified macro_name within the source code.
pub(in crate)
fn compile (
    mod_name: &'_ Ident,
    input: TokenStream2,
) -> Result<TokenStream2>
{Ok({
    #[cfg(feature = "trace-macros")] {
        println!("<<<\ncompile! {{");
        crate::utils::log_stream(input.to_string());
        println!("}}\n=== yields ===");
    }
    let mut file = ::syn::parse2(input)?;
    let macro_names_and_attrs = extract_macro_names_and_attrs(&mut file)?;
    // Same as the input, but with the attributes stripped. (It is a pity that
    // we have to do this, since we lose the input code formatting
    // for more readable spans (and running `rustfmt` here would be overkill))
    let ref src = quote!( #file ).to_string();
    let ref wasm_path =
        compile_to_wasm(mod_name, src)
            .map_err(|err| {
                if cfg!(feature = "trace-macros") {
                    eprintln!("{}", err);
                }
                ::syn::Error::new(Span::call_site(),
                    "Compilation of the procedural macro failed",
                )
            })?
    ;
    let ret = macro_defs(mod_name, wasm_path, macro_names_and_attrs);
    #[cfg(feature = "trace-macros")] {
        crate::utils::log_stream(ret.to_string());
        println!(">>>\n");
    }
    ret
})}

/// Pretty self-explanatory
fn macro_defs (
    mod_name: &'_ Ident,
    wasm_path: &'_ str,
    macro_names_and_attrs: Vec<(Ident, Vec<Attribute>)>,
) -> TokenStream2
{
    let mut ret = TokenStream2::new();
    macro_names_and_attrs.into_iter().for_each(|(name, attrs)| {
        ret.extend(quote_spanned! { name.span()=>
            #(#attrs)*
            macro_rules! #name {(
                $($proc_macro_input:tt)*
            ) => (
                // Defined in `eval.rs`
                $crate::#mod_name::__inline_proc_macros__eval_wasm__! {
                    #name
                    #wasm_path
                    $($proc_macro_input)*
                }
            )}
        });
    });
    ret.into()
}

/// Iterate over all the `Item`s at the top level of the `File`,
/// 
///   - to find the top-level function definitions,
/// 
///   - that are `#[proc_macro]`-annotated.
/// 
/// It then:
/// 
///   - replaces that attribute with `#[no_mangle] extern "C"` (for the
/// exported `cdylib` that the compiled `.wasm` file represents),
/// 
///   - *takes*  (hence the by_mut input) the other attributes (expected to be
///     the optional `#[macro_export]`, and docstrings), 
/// 
///   - and collects a list of the different names of the so-defined
///     `proc_macro`s.
fn extract_macro_names_and_attrs (file: &'_ mut ::syn::File)
  -> Result<Vec<(Ident, Vec<Attribute>)>>
{Ok({
    let mut macro_names_and_attrs = Vec::with_capacity(file.items.len());
    file.items.iter_mut().try_for_each(|item| Ok(match item {
        | &mut Item::Fn(ref mut func) => {
            if {
                // Check for the `proc_macro` attribute, and remove it.
                let mut skip = true;
                func.attrs.retain(|attr| if attr.path.is_ident("proc_macro") {
                    skip = false; // proc_macro fn requires further processing
                    false // pop attr
                } else {
                    true // keep attr
                });
                skip
            }
            {
                return Ok(());
            }
            let ref f_name = func.sig.ident;
            if matches!(func.vis, Visibility::Public(_)).not() {
                return Err(Error::new(
                    f_name.span(),
                    "`#[proc_macro]` function must be `pub`",
                ));
            }
            if let Some(ref abi) = func.sig.abi {
                return Err(Error::new(
                    abi.span(),
                    "`#[proc_macro]` function cannot have an `extern` annotation",
                ));
            }
            macro_names_and_attrs.push((
                f_name.to_owned(),
                ::core::mem::take(&mut func.attrs),
            ));
            // Transform the method into a wasm export.
            func.attrs.push(parse_quote!(#[no_mangle]));
            // func.vis = parse_quote!(pub); /* no need, already the case */
            func.sig.abi.replace(parse_quote!(extern "C"));
        },
        | _ => {},
    }))?;
    macro_names_and_attrs
})}
