<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `macro_use` attr in crate `inline_proc_macros`."><meta name="keywords" content="rust, rustlang, rust-lang, macro_use"><title>inline_proc_macros::macro_use - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc attr"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../inline_proc_macros/index.html'><div class='logo-container'><img src='../rust-logo.png' alt='logo'></div></a><div class="sidebar-elems"><p class='location'><a href='index.html'>inline_proc_macros</a></p><script>window.sidebarCurrent = {name: 'macro_use', ty: 'attr', relpath: ''};</script><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press â€˜Sâ€™ to search, â€˜?â€™ for more optionsâ€¦" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/inline_proc_macros/_lib.rs.html#32-59' title='goto source code'>[src]</a></span><span class='in-band'>Attribute Macro <a href='index.html'>inline_proc_macros</a>::<wbr><a class="attr" href=''>macro_use</a></span></h1><pre class='rust attr'>#[macro_use]</pre><div class='docblock'><p>Annotate a <code>mod</code> declaration to compile its <code>proc_macro</code> source code
into inlined <code>macro_rules!</code> definitions.</p>
<h1 id="usage" class="section-header"><a href="#usage">Usage</a></h1>
<ul>
<li>
<p><strong><code>Cargo.toml</code></strong></p>
<pre><code class="language-toml">[dependencies.inline_proc_macros]
git = &quot;https://github.com/danielhenrymantilla/rust-inline_proc_macros&quot;,
rev = &quot;7c1ac65&quot;  # pin-point commit since it's currently in dev stage
</code></pre>
<ul>
<li>Currently a <code>git</code>-only dependency to prevent it from being used in
production.</li>
</ul>
</li>
<li>
<p><strong><code>build.rs</code></strong></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">main</span> ()
{
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;cargo:rustc-env=OUT_DIR={}&quot;</span>, ::<span class="ident">std</span>::<span class="ident">env</span>::<span class="ident">var</span>(<span class="string">&quot;OUT_DIR&quot;</span>).<span class="ident">unwrap</span>());
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;cargo:rustc-env=RUSTC={}&quot;</span>, ::<span class="ident">std</span>::<span class="ident">env</span>::<span class="ident">var</span>(<span class="string">&quot;RUSTC&quot;</span>).<span class="ident">unwrap</span>());
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;cargo:rerun-if-changed=build.rs&quot;</span>);
}</pre></div>
<details><summary>Remarks</summary>
<p>This indeed hints at the procedural macros doing unorthodox stuff, such
as invoking <code>rustc</code> or using the <code>OUT_DIR</code> filesystem, which are both things
that a <code>build.rs</code> script, instead of a procedural macro, ought to do.</p>
<p>While it is possible to implement the logic of this attribute macro with
a <code>build.rs</code> script, the ergonomics would suffer a lot, making its usability
hardly better that that of using an external <code>proc_macro = &quot;true&quot;</code> crate,
defeating the purpose of the crate.</p>
<p>That being said, Rust does not guarantee that procedural macros be allowed
to interact with their environment like they currently do (it's rather an
unfortunate byproduct of how they are implemented), so <strong>be aware that this
non <code>build.rs</code>-based approach could break with a new Rust release</strong>.</p>
<p>That's why it isn't super advisable to use this crate in production.</p>
<p>That being said, by the time Rust does that change, if it ever does,
we should have a full-featured WASM-encapsulation mechanism for procedural
macros, which should incidentally allow to trivially implement what this
crate achieves, that is, having inline procedural macros built-in into the
build ecosystem, rendering this very crate obsolete.</p>
<p>In other words, by the time this crate breaks, we won't be needing it ðŸ™‚</p>
</summary>
<ul>
<li>
<p>Using a <code>{}</code> instead of a <code>;</code> is necessary since in stable Rust
a procedural macro attribute cannot be applied to a <code>mod name;</code>
declaration.</p>
</li>
<li>
<p>Also, only the top-level module (<code>src/{lib,main}.rs</code>) is supported,
due to limitations of procedural macros (they cannot know whence they
are called), so the source code will always be loaded from
<code>src/some_module_name.rs</code>.</p>
</li>
</ul>
</details>
</li>
<li>
<p><strong><code>src/lib.rs</code></strong> (or <code>src/main.rs</code>)</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">inline_proc_macros</span>::<span class="ident">macro_use</span>]</span>
<span class="kw">mod</span> <span class="ident">some_module_name</span> {}

<span class="comment">// ...</span></pre></div>
<details><summary>Remarks</summary>
<ul>
<li>
<p>Using a <code>{}</code> instead of a <code>;</code> is necessary since in stable Rust
a procedural macro attribute cannot be applied to a <code>mod name;</code>
declaration.</p>
</li>
<li>
<p>Also, only the top-level module (<code>src/{lib,main}.rs</code>) is supported,
due to limitations of procedural macros (they cannot know whence they
are called), so the source code will always be loaded from
<code>src/some_module_name.rs</code>.</p>
</li>
</ul>
</details>
</li>
<li>
<p><strong><code>src/some_module_name.rs</code></strong></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> ::<span class="ident">proc_macro2</span>::<span class="ident">TokenStream</span>;

<span class="doccomment">/// Some docstring    (optional)</span>
<span class="attribute">#[<span class="ident">macro_export</span>]</span>     <span class="comment">// optional</span>
<span class="attribute">#[<span class="ident">proc_macro</span>]</span>       <span class="comment">// required</span>
<span class="kw">pub</span>                 <span class="comment">// required</span>
<span class="kw">fn</span> <span class="ident">some_macro_name</span> (<span class="ident">input</span>: <span class="ident">TokenStream</span>)
  <span class="op">-</span><span class="op">&gt;</span> <span class="ident">TokenStream</span>
{
    <span class="comment">// ...</span>
}</pre></div>
<ul>
<li>
<p><code>#[inline_proc_macros::macro_use]</code> will automagically compile this code
and convert it into something along the lines of:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="doccomment">/// Some docstring</span>
<span class="attribute">#[<span class="ident">macro_export</span>]</span> <span class="comment">// if present in the above code</span>
<span class="macro">macro_rules</span><span class="macro">!</span> <span class="ident">some_macro_name</span> { <span class="comment">/* compiled procedural macro */</span> }</pre></div>
</li>
</ul>
</li>
</ul>
<h2 id="external-crates" class="section-header"><a href="#external-crates">External crates</a></h2>
<p>The only external crates available from within the <code>proc_macro</code> code are:</p>
<ul>
<li>
<p><a href="https://docs.rs/quote"><code>::quote</code></a></p>
</li>
<li>
<p><a href="https://docs.rs/syn"><code>::syn</code></a></p>
</li>
</ul>
<h2 id="examples" class="section-header"><a href="#examples">Examples</a></h2><h3 id="reversing-the-chars-of-a-string-literal-at-compile-time" class="section-header"><a href="#reversing-the-chars-of-a-string-literal-at-compile-time">Reversing the <code>char</code>s of a string literal at compile-time</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="doccomment">//! src/proc_macros.rs</span>

<span class="kw">use</span> ::<span class="ident">proc_macro2</span>::<span class="ident">TokenStream</span>;
<span class="kw">use</span> ::<span class="ident">syn</span>::<span class="kw-2">*</span>;

<span class="attribute">#[<span class="ident">proc_macro</span>]</span> <span class="kw">pub</span>
<span class="kw">fn</span> <span class="ident">reverse</span> (<span class="ident">input</span>: <span class="ident">TokenStream</span>)
  <span class="op">-</span><span class="op">&gt;</span> <span class="ident">TokenStream</span>
{
    <span class="kw">let</span> <span class="ident">input</span>: <span class="ident">LitStr</span> <span class="op">=</span> <span class="macro">parse_macro_input</span><span class="macro">!</span>(<span class="ident">input</span>);
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">string</span>: <span class="ident">String</span> <span class="op">=</span> <span class="ident">input</span>.<span class="ident">value</span>();
    <span class="ident">string</span> <span class="op">=</span> <span class="ident">string</span>.<span class="ident">chars</span>().<span class="ident">rev</span>().<span class="ident">collect</span>();
    ::<span class="ident">quote</span>::<span class="macro">quote</span><span class="macro">!</span>(
        #<span class="ident">string</span>
    ).<span class="ident">into</span>()
}</pre></div>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="doccomment">//! src/main.rs</span>

<span class="attribute">#[<span class="ident">inline_proc_macros</span>::<span class="ident">macro_use</span>]</span>
<span class="kw">mod</span> <span class="ident">proc_macros</span> {}

<span class="kw">fn</span> <span class="ident">main</span> ()
{
    <span class="macro">assert_eq</span><span class="macro">!</span>(
        <span class="macro">reverse</span><span class="macro">!</span>(<span class="string">&quot;!dlroW ,olleH&quot;</span>),
        <span class="string">&quot;Hello, World!&quot;</span>,
    )
}</pre></div>
<h3 id="ffi-compatible-string-literals" class="section-header"><a href="#ffi-compatible-string-literals">FFI-compatible string literals</a></h3>
<p>No more:</p>
<ul>
<li>
<p><code>CStr::from_bytes_with_nul(b&quot;Hello, World!\0&quot;).unwrap()</code>,</p>
</li>
<li>
<p>or worse, <code>CString::new(&quot;Hello, World&quot;).unwrap()</code>!</p>
</li>
</ul>
<p>Instead, you can do:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="doccomment">//! src/proc_macros.rs</span>

<span class="kw">use</span> ::<span class="ident">proc_macro2</span>::<span class="ident">TokenStream</span>;
<span class="kw">use</span> ::<span class="ident">syn</span>::<span class="kw-2">*</span>;

<span class="doccomment">/// Converts an input string literal into a `&amp;&#39;static CStr`, after appending</span>
<span class="doccomment">/// a terminating null-byte if none were found, and producing a **compile-time</span>
<span class="doccomment">/// error** (instead of at runtime!) if the string literal contains an inner</span>
<span class="doccomment">/// null byte.</span>
<span class="attribute">#[<span class="ident">proc_macro</span>]</span> <span class="kw">pub</span>
<span class="kw">fn</span> <span class="ident">c_str</span> (<span class="ident">input</span>: <span class="ident">TokenStream</span>)
  <span class="op">-</span><span class="op">&gt;</span> <span class="ident">TokenStream</span>
{
    <span class="kw">let</span> <span class="ident">input</span>: <span class="ident">LitStr</span> <span class="op">=</span> <span class="macro">parse_macro_input</span><span class="macro">!</span>(<span class="ident">input</span>);
    <span class="kw">let</span> <span class="kw-2">ref</span> <span class="kw-2">mut</span> <span class="ident">bytes</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">input</span>.<span class="ident">value</span>().<span class="ident">into</span>();
    <span class="kw">match</span> <span class="ident">bytes</span>.<span class="ident">iter</span>().<span class="ident">position</span>(<span class="op">|</span><span class="kw-2">&amp;</span><span class="ident">b</span><span class="op">|</span> <span class="ident">b</span> <span class="op">=</span><span class="op">=</span> <span class="string">b&#39;\0&#39;</span>) {
        <span class="op">|</span> <span class="prelude-val">None</span> <span class="op">=</span><span class="op">&gt;</span> {
            <span class="comment">// No null byte at all, append one.</span>
            <span class="ident">bytes</span>.<span class="ident">push</span>(<span class="string">b&#39;\0&#39;</span>);
        },
        <span class="op">|</span> <span class="prelude-val">Some</span>(<span class="ident">idx</span>) <span class="kw">if</span> <span class="ident">idx</span> <span class="op">+</span> <span class="number">1</span> <span class="op">=</span><span class="op">=</span> <span class="ident">bytes</span>.<span class="ident">len</span>() <span class="op">=</span><span class="op">&gt;</span> {
            <span class="comment">/* The string literal already has a terminating null byte. */</span>
        },
        <span class="op">|</span> <span class="prelude-val">Some</span>(<span class="ident">bad_idx</span>) <span class="op">=</span><span class="op">&gt;</span> {
            <span class="comment">// Inner null byte!</span>
            <span class="kw">return</span> <span class="ident">Error</span>::<span class="ident">new_spanned</span>(
                <span class="ident">input</span>,
                <span class="kw-2">&amp;</span><span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;Error, found inner null byte at index {}&quot;</span>, <span class="ident">bad_idx</span>),
            ).<span class="ident">to_compile_error</span>().<span class="ident">into</span>();
        },
    }
    <span class="comment">// Now `bytes` is null-terminated and has no inner nulls.</span>
    <span class="kw">let</span> <span class="ident">checked_byte_str</span> <span class="op">=</span> <span class="ident">LitByteStr</span>::<span class="ident">new</span>(<span class="ident">bytes</span>, <span class="ident">input</span>.<span class="ident">span</span>());
    ::<span class="ident">quote</span>::<span class="macro">quote</span><span class="macro">!</span>(
        <span class="kw">unsafe</span> {
            ::<span class="ident">std</span>::<span class="ident">ffi</span>::<span class="ident">CStr</span>::<span class="ident">from_bytes_with_nul_unchecked</span>(
                #<span class="ident">checked_byte_str</span> <span class="comment">// b&quot;...\0&quot;</span>
            )
        }
    ).<span class="ident">into</span>()
}</pre></div>
<ul>
<li><details><summary><code>no_std</code>-compatible expansion</summary>
<p>It's just a matter of expanding to a <code>&amp;'static [u8]</code> instead of
<code>&amp;'static CStr</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// Now `bytes` is null-terminated and has no inner nulls.</span>
::<span class="ident">quote</span>::<span class="macro">quote</span><span class="macro">!</span>(
    {
        <span class="comment">// Use a constant to coerce to a slice while remaining</span>
        <span class="comment">// `const`-compatible</span>
        <span class="kw">const</span> <span class="ident">IT</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> [<span class="ident">u8</span>] <span class="op">=</span> #<span class="ident">checked_byte_str</span>;
        <span class="ident">IT</span>
    }
).<span class="ident">into</span>()</pre></div>
</details>
</li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="doccomment">//! src/main.rs</span>

<span class="kw">use</span> ::<span class="ident">std</span>::<span class="ident">ffi</span>::<span class="ident">CStr</span>;

<span class="attribute">#[<span class="ident">inline_proc_macros</span>::<span class="ident">macro_use</span>]</span>
<span class="kw">mod</span> <span class="ident">proc_macros</span> {}

<span class="kw">mod</span> <span class="ident">libc</span> {
    <span class="kw">pub</span>
    <span class="kw">use</span> ::<span class="ident">std</span>::<span class="ident">os</span>::<span class="ident">raw</span>::{<span class="ident">c_char</span>, <span class="ident">c_int</span>};

    <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> {
        <span class="kw">pub</span>
        <span class="kw">fn</span> <span class="ident">puts</span> (<span class="kw">_</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">c_char</span>)
          <span class="op">-</span><span class="op">&gt;</span> <span class="ident">c_int</span>
        ;
    }
}

<span class="kw">fn</span> <span class="ident">main</span> ()
{
    <span class="kw">let</span> <span class="ident">hello</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">CStr</span> <span class="op">=</span> <span class="macro">c_str</span><span class="macro">!</span>(<span class="string">&quot;Hello, World&quot;</span>);
    <span class="comment">// let err: &amp;&#39;static CStr = c_str!(&quot;Hell\0, World!&quot;); /* Compile error */</span>
    <span class="kw">unsafe</span> {
        <span class="ident">libc</span>::<span class="ident">puts</span>(<span class="ident">hello</span>.<span class="ident">as_ptr</span>());
    }
}</pre></div>
<ul>
<li><details><summary>Compile-time error message if inner null</summary>
<pre><code class="language-text">error: Error, found inner null byte at index 4
  --&gt; src/main.rs:23:37
   |
23 |     let err: &amp;'static CStr = c_str!(&quot;Hell\0, World!&quot;); /* Compile error */
   |                                     ^^^^^^^^^^^^^^^^
</code></pre>
</details>
</li>
</ul>
</div></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../";window.currentCrate = "inline_proc_macros";</script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>